

;----------------------------------------------------------------------------------------------------
;
;	APP do cronometro
;
;----------------------------------------------------------------------------------------------------
;

;------------------------------------------------------------------------------
; Endere�os das v�rias �reas do boot e do PP
;------------------------------------------------------------------------------
_INICIO:	equ	h0100		; in�cio do programa de aplica��o

_AVR:		equ	h8000

_ARI:		equ	h8100

_ATI:		equ	h8400

_APR:		equ	hFF80
_IOAREA16:	equ	hFF80		; area de perifericos, acessada na base 16 bits
_IOAREA08:	equ	hFFC0		; area de perifericos, acessada na base 8 bits

;
;------------------------------------------------------------------------------
;	�rea reservada para os perif�ricos
;------------------------------------------------------------------------------

; Acesso em 16 bits
	org	_IOAREA16
	daw	[31]
IVET:	dw	0		; Vetor de interrup��o

; Acesso em 8 bits
	org	_IOAREA08
	dab	[23]
TIMDT:	db	0		; Registro de programa��o do timer
INTS:	db	0		; INTERRUPT STATUS: IP x x x . x x IPStec IPStim
INTE:	db	0		; INTERRUPT ENABLE: IE x x x . x x IEStec IEStim
TECST:	db	0		; Status do teclado
TECDT:	db	0		; Dado do teclado
VISOR:	dab	[36]		; Portas de acesso ao visor


;
;----------------------------------------------------------------------------------------------------
;	Fun��es usadas para ler/escrever no rel�gio
;----------------------------------------------------------------------------------------------------
_ROTINAS:	equ	h0080
SET_TIME:	equ	0
GET_TIME:	equ	1


;
;------------------------------------------------------------------------------
;	Vari�veis de comunica��o entre o programa principal e a rotina de atendimento de interrup��es
;------------------------------------------------------------------------------
	org	_AVR
HORA:	DW	0
MINUTO:	DW	0
SEGUNDO:DW	0
TECLA:	DW	0


;
;----------------------------------------------------------------------------------------------------
;	Aplica��o de exemplo
;----------------------------------------------------------------------------------------------------
	org	_INICIO

	desloc: dw 29 	;;Local a inserir o novo digito, nao pode apagar se for 29 e nem adicionar se for 32 


	mov #'I', VISOR
	mov #'n', VISOR+1
	mov #'f', VISOR+2
	mov #'o', VISOR+3
	mov #'r', VISOR+4
	mov #'m', VISOR+5
	mov #'e', VISOR+6
	mov #' ', VISOR+7
	mov #'h', VISOR+8
	mov #'o', VISOR+9
	mov #'r', VISOR+10
	mov #'a', VISOR+11
	mov #' ', VISOR+12
	mov #'i', VISOR+13
	mov #'n', VISOR+14
	mov #'i', VISOR+15
	mov #'c', VISOR+16
	mov #'i', VISOR+17
	mov #'a', VISOR+18
	mov #'l', VISOR+19
	mov #' ', VISOR+20
	mov #'(', VISOR+21
	mov #'H', VISOR+22
	mov #'H', VISOR+23
	mov #'M', VISOR+24
	mov #'M', VISOR+25
	mov #')', VISOR+26
	mov #':', VISOR+27
	mov #' ', VISOR+28
	mov #'_', VISOR+29


	mov desloc, r4	;; SALVANDO A VARIAVEL DESLOCAMENTO EM R4 
;;Loop da entrada de dados
Loop:
	mov TECLA, r5	;; Coloca a tecla no r5 para testar seu valor
	bpl TemTecla	;; Se o numero nao for negativo quer dizer que eh um dado relevante
	jmp Loop


TemTecla:
	cmp r5, #8 		;; Compara a tecla em r5 com h0008 que equivale a tecla backspace
	beq TrataBackspace	;; Se nao for igual a zero vai pro teste que ve se eh enter
	cmp r5, #h000D		;; Compara a tecla em r5 com h000D - a tecla ENTER
	beq TrataEnter
	jmp TestaNumero		;; Testa se a entrada eh um numero e depois volta para o loop esperando input


TrataBackspace:
	cmp #29, r4
	bne EhBackspace
	jmp FimTecla ;;Se o r4 (desloc) estiver na posicao 29, vai para o fim do tratamento de tecla, ie, ignora o backspace
EhBackspace:
	;;Aqui apaga a ultima tecla digitada
	mov #0, VISOR(r4)  	;;apaga
	dec r4		;;subtrai 1 de desloc
	mov #'_', VISOR(r4)	;;coloca o '_' na nova posicao de desloc
	jmp FimTecla		;;da um jump pro fim do tratamento de tecla

;-------------------------------------------------------------------------------------------------------------------------------------
;;Testando se eh enter e se a entrada eh valida
TrataEnter:
	cmp #33, r4		;;Confere se tem 4 digitos na entrada
	bne InputCurto		;;Se r4 (desloc) != 32 entao nao tem 4 digitos na entrada ou seja vai pra uma funcao que avisa disso 

	;;Testando o MSB da hora
	mov VISOR+29, r3 	;;Coloca o MSB da hora no r3 para testar
	cmp r3, #h30		;;faz r3 - 30
	bmi ErroNaHora		;; erro se < 0
	cmp #h32, r3
	bmi ErroNaHora		;; erro se > 2
	
	;;Testando o LSB da hora
	mov VISOR+30, r3 	;;Coloca o LSB da hora no r3 para testar
	cmp r3, #h30		;;faz r3 - 30
	bmi ErroNaHora		;; erro se < 0
	cmp #h33, r3
	bmi ErroNaHora		;; erro se > 3

	jmp TestaMinutos

ErroNaHora:	jmp ErroHorario

TestaMinutos:

	;;Testando o MSB do minuto
	mov VISOR+31, r3 	;;Coloca o MSB da do minuto no r3 para testar
	cmp r3, #h30		;;faz r3 - 30
	bmi ErroNoMinuto	;; erro se < 0
	cmp #h35, r3
	bmi ErroNoMinuto	;; erro se > 5
	
	;;Testando o LSB do minuto
	mov VISOR+32, r3 	;;Coloca o MSB da hora no r3 para testar
	cmp r3, #h30		;;faz r3 - 30
	bmi ErroNoMinuto	;; erro se < 0
	cmp #h39, r3
	bmi ErroNoMinuto	;; erro se > 9

	jmp InputCerto		;; Se passou por todos os comecao cronometro mesmo

ErroNoMinuto:	jmp ErroMinuto


InputCurto:
	mov #'t', VISOR
	mov #'e', VISOR+1
	mov #'m', VISOR+2
	mov #'p', VISOR+3
	mov #'o', VISOR+4
	mov #' ', VISOR+5
	mov #'i', VISOR+6
	mov #'n', VISOR+7
	mov #'i', VISOR+8
	mov #'c', VISOR+9
	mov #'i', VISOR+10
	mov #'a', VISOR+11
	mov #'l', VISOR+12
	mov #' ', VISOR+13
	mov #'i', VISOR+14
	mov #'n', VISOR+15
	mov #'c', VISOR+16
	mov #'o', VISOR+17
	mov #'m', VISOR+18
	mov #'p', VISOR+19
	mov #'l', VISOR+20
	mov #'e', VISOR+21
	mov #'t', VISOR+22
	mov #'o', VISOR+23
	mov #' ', VISOR+24
	mov #' ', VISOR+25
	mov #' ', VISOR+26
	mov #' ', VISOR+27
	mov #' ', VISOR+28
	mov #' ', VISOR+29
	mov #' ', VISOR+30
	mov #' ', VISOR+31
	mov #' ', VISOR+32
	mov #' ', VISOR+33
	mov #' ', VISOR+34

	jmp Reset		;;loop que fica aguardando o usuario digitar enter

ErroHorario:
	mov #'H', VISOR
	mov #'o', VISOR+1
	mov #'r', VISOR+2
	mov #'a', VISOR+3
	mov #'r', VISOR+4
	mov #'i', VISOR+5
	mov #'o', VISOR+6
	mov #' ', VISOR+7
	mov #'i', VISOR+8
	mov #'n', VISOR+9
	mov #'v', VISOR+10
	mov #'a', VISOR+11
	mov #'l', VISOR+12
	mov #'i', VISOR+13
	mov #'d', VISOR+14
	mov #'o', VISOR+15
	mov #' ', VISOR+16
	mov #' ', VISOR+17
	mov #' ', VISOR+18
	mov #' ', VISOR+19
	mov #' ', VISOR+20
	mov #' ', VISOR+21
	mov #' ', VISOR+22
	mov #' ', VISOR+23
	mov #' ', VISOR+24
	mov #' ', VISOR+25
	mov #' ', VISOR+26
	mov #' ', VISOR+27
	mov #' ', VISOR+28
	mov #' ', VISOR+29
	mov #' ', VISOR+30
	mov #' ', VISOR+31
	mov #' ', VISOR+32
	mov #' ', VISOR+33
	mov #' ', VISOR+34

	jmp Reset		;;loop que fica aguardando o usuario digitar enter

ErroMinuto:
	mov #'M', VISOR
	mov #'i', VISOR+1
	mov #'n', VISOR+2
	mov #'u', VISOR+3
	mov #'t', VISOR+4
	mov #'o', VISOR+5
	mov #' ', VISOR+6
	mov #'i', VISOR+7
	mov #'n', VISOR+8
	mov #'v', VISOR+9
	mov #'a', VISOR+10
	mov #'l', VISOR+11
	mov #'i', VISOR+12
	mov #'d', VISOR+13
	mov #'o', VISOR+14
	mov #' ', VISOR+15
	mov #' ', VISOR+16
	mov #' ', VISOR+17
	mov #' ', VISOR+18
	mov #' ', VISOR+19
	mov #' ', VISOR+20
	mov #' ', VISOR+21
	mov #' ', VISOR+22
	mov #' ', VISOR+23
	mov #' ', VISOR+24
	mov #' ', VISOR+25
	mov #' ', VISOR+26
	mov #' ', VISOR+27
	mov #' ', VISOR+28
	mov #' ', VISOR+29
	mov #' ', VISOR+30
	mov #' ', VISOR+31
	mov #' ', VISOR+32
	mov #' ', VISOR+33
	mov #' ', VISOR+34

Reset:
	mov #-1, TECLA	;; Reseta a tecla pois o loop nao usou a tecla antiga

	;;loop que fica aguardando o usuario digitar enter
LoopReset:
	mov TECLA, r5	;; Coloca a tecla no r5 para testar seu valor
	bpl AlgoUtil	;; Tem um numero nao negativo na tecla
	jmp LoopReset

AlgoUtil:
	cmp r5, #h000D	;; Compara a tecla em r5 com h000D - a tecla ENTER
	beq Reseta
	tst TECLA	;;testa se tecla tem um valor positivo
	bpl Reset	;;Se tiver um valor nao negativo e nao for enter coloca o -1 na tecla novamente
	jmp LoopReset

Reseta:	
	mov #-1, TECLA	;; Reseta a tecla e volta para o inicio do programa
	jmp _INICIO 	;; Volta para o comeco do programa

;-------------------------------------------------------------------------------------------------------------------------------------

TestaNumero:

	;Comeca testando se esta entre 0-9
	cmp r5, #h30
	bmi FimTecla	;; Se for negativo quer dizer que eh < 0, portanto deve ignorar
	cmp #h39, r5
	bmi FimTecla	;; Se for negativo quer dizer que eh > 9, portanto deve ignorar

	;Agora testa se ja tem 4 digitos no visor
	cmp #33, r4	;;Confere se tem 4 digitos na entrada
	beq FimTecla	;;Se ja tiver 4 digitos ele simplesmente ignora a entrada de outro

	;Finalmente, insere a tecla depois de todos os teste
	mov r5, VISOR(r4)	;;Coloca a tecla na posicao atual do desloc
	inc r4		;;incrementa o deslocamento
	mov #'_', VISOR(r4)	;;coloca '_' na outra posicao

	jmp FimTecla ;


FimTecla:
	mov #-1, TECLA	;;Coloca -1 na tecla??
	jmp Loop	;;Volta pro loop de input

	;*****AQUI EH ONDE O VALOR DE TECLA SERA RESETADO PARA UM NUMERO NEGATIVO PARA FAZER COM QUE A INTERRUPCAO FUNCIONE CORRETAMENTE
	 ;*****DEPOIS FAZER UM JMP PRO LOOP

InputCerto:
	;*****COMECAR ISSO LIMPANDO A TECLA TBM, ASSIM COMO NO FIM TECLA
